package goping

import (
	"errors"
	"math"
	"net"
	"sync"
	"sync/atomic"
	"time"
)

/*** Errors ***/
var (
	ErrTimeout        = errors.New("Timeout")
	ErrDstUnreachable = errors.New("Destination Unreachable")
	ErrParamProblem   = errors.New("Parameter problem")
	ErrTimeExceeded   = errors.New("Time Exceeded")
	ErrRedirect       = errors.New("Redirect Message")
	ErrUnknown        = errors.New("Unknown Packet")

	ErrPingerNotRegistered = errors.New("Ping not registered")
)

/*** Pinger Registry ***/
var (
	pregistry      map[string]Pinger
	pregistryMutex sync.Mutex
)

func RegPingerAdd(name string, pinger Pinger) {
	pregistryMutex.Lock()
	defer pregistryMutex.Unlock()
	if pregistry == nil {
		pregistry = make(map[string]Pinger)
	}
	pregistry[name] = pinger
}
func RegPingerGet(name string) (Pinger, error) {
	pregistryMutex.Lock()
	defer pregistryMutex.Unlock()
	if pinger, ok := pregistry[name]; ok {
		return pinger, nil
	} else {
		return nil, ErrPingerNotRegistered
	}
}
func RegPingerList() []string {
	pregistryMutex.Lock()
	defer pregistryMutex.Unlock()
	names := make([]string, len(pregistry))
	i := 0
	for name := range pregistry {
		names[i] = name
		i++
	}
	return names
}

/*** Structures ***/

//Config is the configures a GoPing object
type Config struct {
	Count      int
	Interval   time.Duration
	Timeout    time.Duration
	TOS        int
	TTL        int
	PacketSize int
}

//Request represents a Ping Job. A request can generate 1 to Count responses
type Request struct {
	Id       uint64
	Host     string
	Config   Config
	UserData map[string]string

	//Statistics
	Sent float64
}

//Response is sent for each Request Count iteration
type Response struct {
	Request Request
	Seq     int
	Err     error
	RawResponse
}

//RawResponse: Responses generated by the pinger implementation
type RawResponse struct {
	RTT         float64
	Peer        net.IP
	ICMPMessage []byte
}

/*** Interfaces ***/

//Represent an logger object
type Logger interface {
	Warn(fmt string, v ...interface{})
	Info(fmt string, v ...interface{})
	Severe(fmt string, v ...interface{})
	IsDebug() bool
	Debug(fmt string, v ...interface{})
}

//Pinger is responsible for send and receive pings over the network
type Pinger interface {
	Ping(r Request, seq int) (future <-chan RawResponse, err error)
}

//GoPing Coordinates ping requests and responses
type Gopinger interface {
	NewRequest(hostname string, userData map[string]string) Request
	Start() (chan<- Request, <-chan Response)
}

//SequenceGenerator returns a sequence number to be used in the ICMP sequence field.
type SequenceGenerator interface {
	Next(r Request) int
}
type seqGenerator struct {
	totalPings uint64
}

func (s *seqGenerator) Next(r Request) int {
	//Incrementing totalPings and getting sequence number
	return int(atomic.AddUint64(&(s.totalPings), 1) % 65536)
}

/*** Interface Implementation ***/
type goping struct {
	idGen  uint64
	cfg    Config
	log    Logger
	pinger Pinger
	seqGen SequenceGenerator
}

func (g *goping) NewRequest(hostname string, userData map[string]string) Request {
	id := atomic.AddUint64(&(g.idGen), 1)
	return Request{
		Id:       id,
		Host:     hostname,
		Config:   g.cfg,
		UserData: userData,
	}
}

func (g *goping) Start() (chan<- Request, <-chan Response) {
	in := make(chan Request)
	pin := make(chan Request)
	out := make(chan Response)
	doneIn := make(chan struct{})
	done := make(chan struct{})
	var wg sync.WaitGroup

	go func(in chan Request, out chan Response) {
		for {
			select {
			case recv, open := <-in:
				if !open {
					//Stop reading from channel
					in = nil
					go func() {
						//Send signal to doneIn because channel is closed
						doneIn <- struct{}{}
					}()
				} else {
					wg.Add(1)
					if recv.Config.Count == 0 {
						//Request  Count is 0. Job is done without sending any requests
						wg.Done()
					} else {
						//Send request to be processed
						go func() {
							pin <- recv
						}()
					}
				}

			case recv := <-pin:
				//Incrementing Request Sent Counter
				recv.Sent++

				//Getting next sequence number
				seq := g.seqGen.Next(recv)

				//Calling Ping method of the pinger interface
				future, err := g.pinger.Ping(recv, seq)

				//waiting for a response in a goroutine
				go func(recv Request, future <-chan RawResponse, seq int, err error) {

					//Builds the response object
					resp := Response{
						Request:     recv,
						Seq:         seq,
						Err:         err,
						RawResponse: RawResponse{RTT: math.NaN()},
					}

					//Start a timer to the request interval
					waitInterval := time.After(recv.Config.Interval)

					if resp.Err == nil {
						timeout := time.After(recv.Config.Timeout)
						select {
						case <-timeout:
							resp.Err = ErrTimeout
						case r := <-future:
							resp.RawResponse = r
							switch r.ICMPMessage[0] {
							case 0:
								//Received an Echo Reply
							case 3:
								//Destination unreachable
								resp.Err = ErrDstUnreachable
							case 5:
								//Received a redirect message
								resp.Err = ErrRedirect
							case 11:
								//Received a time exceeded error
								resp.Err = ErrTimeExceeded
							case 12:
								//Parameter Problema - Bad Ip Header
								resp.Err = ErrParamProblem
							case 8:
								//Received an echo request
							default:
								//Received an unknonw message
								resp.Err = ErrUnknown
							}
						}
					}

					//Send response to out channel. Blocks until user consumes it
					out <- resp

					if recv.Config.Count >= 0 && int(recv.Sent) >= recv.Config.Count {
						//This was the last request. Job Done
						wg.Done()
					} else {
						//We still have more requests to do. Waits for the request interval and send request to pin channel again
						<-waitInterval
						pin <- recv
					}
				}(recv, future, seq, err)

			case <-doneIn:
				go func(wg *sync.WaitGroup, out chan Response, done chan struct{}) {
					wg.Wait()
					close(out)
					done <- struct{}{}
				}(&wg, out, done)

			case <-done:
				return
			}
		}

	}(in, out)

	return in, out
}

/*** Constructors ***/
func New(cfg Config, log Logger, pinger Pinger, seqGen SequenceGenerator) Gopinger {
	return &goping{
		cfg:    cfg,
		log:    log,
		pinger: pinger,
		seqGen: seqGen,
	}
}

var defSeqGen *seqGenerator
var defSeqGenOnce sync.Once

func DefaultSeqGen() SequenceGenerator {
	defSeqGenOnce.Do(func() { defSeqGen = new(seqGenerator) })
	return defSeqGen
}
