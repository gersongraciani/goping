package goping

import (
	//"bytes"
	//"encoding/binary"
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"syscall"
	"time"

	"golang.org/x/net/icmp"
	"golang.org/x/net/ipv4"
)

const (
	SOF_TIMESTAMPING_TX_HARDWARE = (1 << 0)
	SOF_TIMESTAMPING_TX_SOFTWARE = (1 << 1)
)

//Send Icmp Packets over the network
//Receives request from the Ping Channel
//Register the new sequence in the pingarray that the receiver will send the timestamp
//Send Icmp Packet through the network
//Puts the Request back on the pong channel. The caller will verify the response and timeout
func pinger(ping chan Ping, pong chan Ping, pingInterval time.Duration) {

	//Maintains a sequence number
	var seq int

	//Initializes the slices that will receive the time channels
	pingarray := make([]chan time.Time, maxseq)

	//Starts the icmp Listener in a goroutine
	//go receiver(conn, pingarray)
	go receiver(pingarray)

	//Create a raw socket to read icmp packets
	fd, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_ICMP)

	//Set the option to receive the kernel timestamp from each received message
	if err := syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TIMESTAMPING, (SOF_TIMESTAMPING_TX_HARDWARE | SOF_TIMESTAMPING_TX_SOFTWARE)); err != nil {
		log.Fatal("Could not set sock opt syscall")
	}
	if err := syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TIMESTAMP, 1); err != nil {
		log.Fatal("Could not set sock opt syscall")
	}

	if err := syscall.SetsockoptInt(fd, syscall.IPPROTO_IP, syscall.IP_HDRINCL, 1); err != nil {
		log.Fatal("Could not set sock opt syscall HDRINCL")
	}

	//Used for receive the error message from socket informing the timstamp
	rfds := &syscall.FdSet{}
	timeout := &syscall.Timeval{Sec: 10}

	//The engine loop
	for pi := range ping {

		//Increment the sequence number and assigns to pi.Seq
		seq = (seq + 1) % maxseq

		//wb[6], wb[7] = uint8(seq>>8), uint8(seq&0xff)

		//Set the sequence number to the ping request
		pi.Seq = seq

		//Initializes the channel to receive the Pong
		pi.rttchan = make(chan time.Time, 1)

		//Registers the seq and the channel in the ping array
		//The listener will send a timestamp message to this channel
		//WHen the message arrives
		pingarray[seq] = pi.rttchan

		//Sets the sequence number into the binary packet
		//		wb[6], wb[7] = uint8(seq>>8), uint8(seq&0xff)

		//Uses the ipv4 and icmp packets to help build the packets
		//Builds the icmp message
		wm := icmp.Message{
			Type: ipv4.ICMPTypeEcho,
			Code: 0,
			Body: &icmp.Echo{
				ID:   os.Getpid() & 0xffff,
				Data: make([]byte, 56),
				Seq:  seq,
			},
		}
		//Encode the ICMP Packet into a binary representation
		wb, err := wm.Marshal(nil)
		if err != nil {
			log.Fatal(err)
		}

		//Builds the ip Header
		iph := ipv4.Header{
			Version:  4,
			Len:      20,
			TOS:      0,
			TotalLen: 20 + len(wb), // 20 bytes for IP, len(wb) for ICMP
			TTL:      64,
			Protocol: 1, // ICMP
			Dst:      pi.toaddr.IP,
		}
		ipb, err := iph.Marshal()
		if err != nil {
			log.Fatal(err)
		}

		//Builds the packet append ip header and icmp message

		pkt := append(ipb, wb...)

		//Builds the target SockaddrInet4
		ipb = pi.toaddr.IP.To4()
		to := syscall.SockaddrInet4{
			Port: 0,
			Addr: [4]byte{
				ipb[0],
				ipb[1],
				ipb[2],
				ipb[3],
			},
		}

		//Setting the time before send the packet
		pi.When = time.Now()

		//Sending the packet through the network
		err = syscall.Sendto(fd, pkt, 0, &to)
		if err != nil {
			fmt.Println("Error Sending Message", err)
			pi.Pong = Pong{Err: err}
		}

		//Waiting the message from error socket to be available
		fmt.Println(" waiting select")
		FD_ZERO(rfds)
		FD_SET(rfds, fd)
		_, err = syscall.Select(fd+1, nil, nil, rfds, timeout)
		if err != nil {
			fmt.Println("Error waiting select")
			log.Fatalln(err)
		}

		//Buffer to receive the error message
		buf := make([]byte, 1024)

		//Buffer to receive the error control message
		oob := make([]byte, 64)

		//Receives a message from the socket sent by the kernel
		fmt.Println("BEFORE READING THE ERROR QUEUE ", time.Now().Sub(pi.When))
		if _, oobn, _, _, err2 := syscall.Recvmsg(fd, buf, oob, syscall.MSG_ERRQUEUE); err2 != nil {
			log.Fatal(err2)
		} else {

			//Parse the received control message until the oobn size
			cmsgs, err := syscall.ParseSocketControlMessage(oob[:oobn])
			if err != nil {
				log.Fatal(os.NewSyscallError("parse socket control message", err))
			}

			//Iterate over the control messages
			for _, m := range cmsgs {
				//Continue if control message is not syscall.SOL_SOCKET
				if m.Header.Level != syscall.SOL_SOCKET {
					continue
				}
				//Control Message is SOL_SOCKET, Verifyng if syscall is SO_TIMESTAMP
				switch m.Header.Type {
				case syscall.SO_TIMESTAMP:
					//Found Timestamp. Using binary package to read from
					fmt.Println("SO_TIMESTAMP ", time.Now().Sub(pi.When))
					var tv syscall.Timeval
					binary.Read(bytes.NewBuffer(m.Data), binary.LittleEndian, &tv)
					pi.When = time.Unix(tv.Unix())
				case syscall.SO_TIMESTAMPING:
					//Found Timestamp. Using binary package to read from
					fmt.Println("SO_TIMESTAMPING ", time.Now().Sub(pi.When))
					var tv syscall.Timeval
					binary.Read(bytes.NewBuffer(m.Data[:16]), binary.LittleEndian, &tv)
					fmt.Println("Hardware: ", time.Unix(tv.Unix()))
					binary.Read(bytes.NewBuffer(m.Data[:16]), binary.LittleEndian, &tv)
					fmt.Println("Software: ", time.Unix(tv.Unix()))

				}
			}

		}

		//Returns the ping through the pong channel. The receiver will send a timestamp if a packet arrived for this sequence
		pong <- pi

		//This  permits other goroutines to run and avoid saturate the socket with too
		//many simultaneous Echo Requests
		time.Sleep(pingInterval)

	}
}
func FD_SET(p *syscall.FdSet, i int) {
	p.Bits[i/64] |= 1 << uint(i) % 64
}

func FD_ISSET(p *syscall.FdSet, i int) bool {
	return (p.Bits[i/64] & (1 << uint(i) % 64)) != 0
}

func FD_ZERO(p *syscall.FdSet) {
	for i := range p.Bits {
		p.Bits[i] = 0
	}
}
