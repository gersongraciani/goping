package goping

import (
	"errors"
	"fmt"
	"math"
	"net"
	"os"
	"sync"
	"sync/atomic"
	"time"
)

/*** Errors ***/
var (
	ErrTimeout        = errors.New("Timeout")
	ErrDstUnreachable = errors.New("Destination Unreachable")
	ErrParamProblem   = errors.New("Parameter problem")
	ErrTimeExceeded   = errors.New("Time Exceeded")
	ErrRedirect       = errors.New("Redirect Message")
	ErrUnknown        = errors.New("Unknown Packet")

	ErrPingerNotRegistered = errors.New("Ping not registered")
)

/*** Pinger Registry ***/
var (
	pregistry      map[string]Pinger
	pregistryMutex sync.Mutex
)

func RegPingerAdd(name string, pinger Pinger) {
	pregistryMutex.Lock()
	defer pregistryMutex.Unlock()
	if pregistry == nil {
		pregistry = make(map[string]Pinger)
	}
	pregistry[name] = pinger
}
func RegPingerGet(name string) (Pinger, error) {
	pregistryMutex.Lock()
	defer pregistryMutex.Unlock()
	if pinger, ok := pregistry[name]; ok {
		return pinger, nil
	} else {
		return nil, ErrPingerNotRegistered
	}
}
func RegPingerList() []string {
	pregistryMutex.Lock()
	defer pregistryMutex.Unlock()
	names := make([]string, len(pregistry))
	i := 0
	for name := range pregistry {
		names[i] = name
		i++
	}
	return names
}

/*** Structures ***/

//Config is the configures a GoPing object
type Config struct {
	Count      int
	Interval   time.Duration
	Timeout    time.Duration
	TOS        int
	TTL        int
	PacketSize int
}

//Request represents a Ping Job. A request can generate 1 to Count responses
type Request struct {
	Id       uint64
	Host     string
	Config   Config
	UserData map[string]string

	//Statistics
	Sent float64
}

//SeqRequest join a sequence field to be passed to unlderlying pingers
type SeqRequest struct {
	Seq int
	Req Request
}

//Response is sent for each Request Count iteration
type Response struct {
	Request Request
	RawResponse
}

//RawResponse: Responses generated by the pinger implementation
type RawResponse struct {
	Seq         int
	RTT         float64
	Peer        net.IP
	ICMPMessage []byte
	Err         error
}

/*** Interfaces ***/

//Represent an logger object
type Logger interface {
	Warn(fmt string, v ...interface{})
	Info(fmt string, v ...interface{})
	Severe(fmt string, v ...interface{})
	IsDebug() bool
	Debug(fmt string, v ...interface{})
}

//Pinger is responsible for send and receive pings over the network
type Pinger interface {
	Start(pid int) (chan<- SeqRequest, <-chan RawResponse, <-chan struct{}, error)
}

//GoPing Coordinates ping requests and responses
type Gopinger interface {
	NewRequest(hostname string, userData map[string]string) Request
	Start() (chan<- Request, <-chan Response, error)
}

//SequenceGenerator returns a sequence number to be used in the ICMP sequence field.
type SequenceGenerator interface {
	Next(rid uint64) int
}
type seqGenerator struct {
	totalPings uint64
}

func (s *seqGenerator) Next(rid uint64) int {
	//Incrementing totalPings and getting sequence number
	return int(atomic.AddUint64(&(s.totalPings), 1) % 65536)
}

/*** Interface Implementation ***/
type goping struct {
	idGen  uint64
	cfg    Config
	log    Logger
	pinger Pinger
	seqGen SequenceGenerator
}

func (g *goping) NewRequest(hostname string, userData map[string]string) Request {
	id := atomic.AddUint64(&(g.idGen), 1)
	return Request{
		Id:       id,
		Host:     hostname,
		Config:   g.cfg,
		UserData: userData,
	}
}

func (g *goping) Start() (chan<- Request, <-chan Response, error) {
	in := make(chan Request)
	pin := make(chan Request)
	out := make(chan Response)
	doneIn := make(chan struct{})
	done := make(chan struct{})
	var wg sync.WaitGroup

	ping, pong, pongdone, err := g.pinger.Start(os.Getpid())
	if err != nil {
		return nil, nil, fmt.Errorf("Could not start pinger: [%v]", err)
	}

	go func(in chan Request, out chan Response, ping chan<- SeqRequest, pong <-chan RawResponse, pongdone <-chan struct{}) {
		holder := make([]chan RawResponse, 65536, 65536)
		for {
			select {

			//Receiving a Request from Client
			case recv, open := <-in:
				if !open {
					//Stop reading from channel
					in = nil
					go func() {
						//Send signal to doneIn because channel is closed
						doneIn <- struct{}{}
					}()
				} else {
					wg.Add(1)
					if recv.Config.Count == 0 {
						//Request  Count is 0. Job is done without sending any requests
						wg.Done()
					} else {
						//Send request to be processed
						go func() {
							pin <- recv
						}()
					}
				}

			//Receiving RawResponse from Pinger
			case rresp, open := <-pong:
				if open {

					//Received a RawResponse from Pinger
					if holder[rresp.Seq] != nil {
						holder[rresp.Seq] <- rresp
						holder[rresp.Seq] = nil
					}
				}

			//Receiving Request from in or pin
			case recv := <-pin:
				//Incrementing Request Sent Counter
				recv.Sent++

				//Create te SeqRequest struct
				sr := SeqRequest{Seq: g.seqGen.Next(recv.Id), Req: recv}

				//Send request to the pinger through the pinger channel
				future := make(chan RawResponse, 1)
				holder[sr.Seq] = future
				ping <- sr

				//waiting for a response in a goroutine
				go func(sr SeqRequest, future <-chan RawResponse) {

					//Builds the response object
					resp := Response{
						Request:     recv,
						RawResponse: RawResponse{Seq: sr.Seq, RTT: math.NaN()},
					}

					//Start a timer to the request interval
					waitInterval := time.After(recv.Config.Interval)

					timeout := time.After(recv.Config.Timeout)
					select {
					case <-timeout:
						resp.Err = ErrTimeout
					case r := <-future:
						resp.RawResponse = r
					}

					//Send response to out channel. Blocks until user consumes it
					out <- resp

					if recv.Config.Count >= 0 && int(recv.Sent) >= recv.Config.Count {
						//This was the last request. Job Done
						wg.Done()
					} else {
						//We still have more requests to do. Waits for the request interval and send request to pin channel again
						<-waitInterval
						pin <- recv
					}
				}(sr, future)

			//Receiving signal that client closed in channel
			case <-doneIn:
				//Waiting the ping processing end. closing ping (pinger) and out(client) channels
				go func(wg *sync.WaitGroup, out chan Response, done chan struct{}) {
					wg.Wait()
					close(ping)
					close(out)
					done <- struct{}{}
				}(&wg, out, done)

			case <-done:
				return
			}
		}

	}(in, out, ping, pong, pongdone)

	return in, out, nil
}

/*** Constructors ***/
func New(cfg Config, log Logger, pinger Pinger, seqGen SequenceGenerator) Gopinger {
	return &goping{
		cfg:    cfg,
		log:    log,
		pinger: pinger,
		seqGen: seqGen,
	}
}

var defSeqGen *seqGenerator
var defSeqGenOnce sync.Once

func DefaultSeqGen() SequenceGenerator {
	defSeqGenOnce.Do(func() { defSeqGen = new(seqGenerator) })
	return defSeqGen
}
